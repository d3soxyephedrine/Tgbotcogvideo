<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ko2 - Unrestricted AI</title>

    <!-- Markdown and Syntax Highlighting Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-cyan: #00d4ff;
            --secondary-blue: #0099cc;
            --dark-bg: #0a0e1a;
            --darker-bg: #060911;
            --card-bg: rgba(15, 23, 42, 0.7);
            --glass-bg: rgba(30, 41, 59, 0.4);
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --error-red: #ef4444;
            --success-green: #10b981;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: var(--dark-bg);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            position: relative;
            touch-action: manipulation;
            -webkit-overflow-scrolling: touch;
        }

        /* Animated Background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 100%);
            pointer-events: none;
        }

        .bg-animation::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(0, 153, 204, 0.1) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
        }

        @keyframes drift {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(-50px, -50px); }
        }

        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--primary-cyan);
            border-radius: 50%;
            animation: float 15s infinite ease-in-out;
            opacity: 0.3;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 0.3;
            }
            90% {
                opacity: 0.3;
            }
            100% {
                transform: translateY(-100vh) translateX(100px);
                opacity: 0;
            }
        }

        .main-wrapper {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: row;
            height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0, 212, 255, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }

        .new-chat-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .new-chat-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        .conversations-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .conversation-item {
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(0, 212, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .conversation-item:hover {
            background: rgba(30, 41, 59, 0.8);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .conversation-item.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--primary-cyan);
        }

        .conversation-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .conversation-meta {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .delete-conversation-btn {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.2s ease;
        }

        .delete-conversation-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--error-red);
        }

        .container {
            position: relative;
            display: flex;
            flex-direction: column;
            flex: 1;
            height: 100vh;
        }

        /* Hamburger Menu Button */
        .menu-toggle {
            display: none;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            color: var(--primary-cyan);
            font-size: 24px;
            line-height: 1;
            transition: all 0.2s ease;
            flex: 0 0 44px;
            min-width: 44px;
            flex-shrink: 0;
        }

        .menu-toggle:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .header-left {
            flex-shrink: 0;
        }

        /* Sidebar Backdrop */
        .sidebar-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 280px;
            width: calc(100% - 280px);
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar-backdrop.active {
            display: block;
            opacity: 1;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .menu-toggle {
                display: block;
            }

            .sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                height: 100vh;
                z-index: 1000;
                transition: left 0.3s ease;
            }

            .sidebar.active {
                left: 0;
            }

            .main-wrapper {
                flex-direction: column;
            }
        }

        /* Header with Logo */
        .header {
            padding: 20px 30px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            animation: pulse-glow 3s ease-in-out infinite;
        }

        .logo img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            }
            50% {
                box-shadow: 0 0 30px rgba(0, 212, 255, 0.8), 0 0 40px rgba(0, 212, 255, 0.4);
            }
        }

        .header-title {
            display: flex;
            flex-direction: column;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 1px;
        }

        .header-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .credit-badge {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 153, 204, 0.2));
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--primary-cyan);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2);
            transition: all 0.3s ease;
        }

        .credit-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
        }

        /* Model Toggle */
        .model-toggle-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--glass-bg);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            backdrop-filter: blur(10px);
        }

        .model-toggle {
            position: relative;
            width: 56px;
            height: 28px;
            background: rgba(148, 163, 184, 0.3);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(148, 163, 184, 0.4);
        }

        .model-toggle.active {
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            border-color: var(--primary-cyan);
        }

        .model-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .model-toggle.active::after {
            transform: translateX(28px);
        }

        .model-label {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 600;
            min-width: 100px;
        }

        .model-cost {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 4px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* Memories Section */
        .memories-section {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }

        .memories-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .memories-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .memory-count-badge {
            font-size: 11px;
            color: var(--text-secondary);
            background: rgba(0, 212, 255, 0.1);
            padding: 4px 10px;
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .add-memory-btn {
            width: 100%;
            padding: 10px;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }

        .add-memory-btn:hover {
            background: rgba(30, 41, 59, 0.8);
            border-color: var(--primary-cyan);
            color: var(--primary-cyan);
        }

        .add-memory-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .memories-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .memories-list::-webkit-scrollbar {
            width: 4px;
        }

        .memories-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .memories-list::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 2px;
        }

        .memory-item {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            position: relative;
            transition: all 0.2s ease;
            animation: slideIn 0.2s ease-out;
        }

        .memory-item:hover {
            background: rgba(30, 41, 59, 0.8);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .memory-content {
            font-size: 12px;
            color: var(--text-primary);
            line-height: 1.4;
            margin-bottom: 6px;
            word-wrap: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .memory-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .memory-date {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .memory-delete-btn {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--error-red);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .memory-delete-btn:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--error-red);
        }

        .memories-empty {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            padding: 20px 10px;
            font-style: italic;
        }

        /* Add Memory Modal */
        .add-memory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            animation: fadeIn 0.3s ease-out;
        }

        .add-memory-modal textarea {
            width: 100%;
            padding: 12px 16px;
            background: var(--glass-bg);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            resize: vertical;
            outline: none;
            transition: all 0.3s ease;
            font-family: inherit;
            margin-bottom: 12px;
        }

        .add-memory-modal textarea:focus {
            border-color: var(--primary-cyan);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }

        .memory-input-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .char-counter {
            color: var(--text-secondary);
        }

        .slots-remaining {
            color: var(--primary-cyan);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cancel-btn {
            background: rgba(148, 163, 184, 0.2);
            color: var(--text-primary);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .cancel-btn:hover {
            background: rgba(148, 163, 184, 0.3);
        }

        .save-btn {
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            color: white;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .save-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
        }

        .save-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Command Palette */
        .command-palette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: none;
            animation: fadeIn 0.15s ease-out;
        }

        .command-palette-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
        }

        .command-palette-content {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 640px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(0, 212, 255, 0.3);
            animation: slideDown 0.2s ease-out;
            overflow: hidden;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .command-search {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .search-icon {
            font-size: 20px;
            opacity: 0.6;
        }

        #command-search-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 500;
        }

        #command-search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .command-close-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .command-close-btn:hover {
            background: rgba(148, 163, 184, 0.2);
            color: var(--text-primary);
        }

        .command-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 8px 0;
        }

        .command-list::-webkit-scrollbar {
            width: 8px;
        }

        .command-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .command-list::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        .command-category {
            padding: 8px 20px;
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 8px;
        }

        .command-item {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 3px solid transparent;
        }

        .command-item:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        .command-item.selected {
            background: rgba(0, 212, 255, 0.1);
            border-left-color: var(--primary-cyan);
        }

        .command-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
            flex-shrink: 0;
        }

        .command-details {
            flex: 1;
            min-width: 0;
        }

        .command-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .command-description {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .command-shortcut {
            font-size: 11px;
            color: var(--text-secondary);
            background: rgba(148, 163, 184, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .command-footer {
            display: flex;
            gap: 16px;
            padding: 12px 20px;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(0, 0, 0, 0.2);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .command-footer kbd {
            background: rgba(148, 163, 184, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .command-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Command Palette FAB */
        .command-palette-fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            border: none;
            color: white;
            font-size: 24px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4);
            z-index: 1500;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            animation: pulse-glow 3s ease-in-out infinite;
        }

        .command-palette-fab:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 35px rgba(0, 212, 255, 0.6);
        }

        .command-palette-fab:active {
            transform: translateY(-1px) scale(1);
        }

        @media (max-width: 768px) {
            .command-palette-fab {
                bottom: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 22px;
            }
        }

        /* Markdown Rendering Styles */
        .message p {
            margin: 0.5em 0;
        }

        .message p:first-child {
            margin-top: 0;
        }

        .message p:last-child {
            margin-bottom: 0;
        }

        .message code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.9em;
            color: var(--primary-cyan);
        }

        .message pre {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 12px 0;
            position: relative;
        }

        .message pre code {
            background: transparent;
            padding: 0;
            color: inherit;
            font-size: 0.9em;
            line-height: 1.5;
            display: block;
        }

        .message a {
            color: var(--primary-cyan);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .message a:hover {
            border-bottom-color: var(--primary-cyan);
            opacity: 0.8;
        }

        .message ul,
        .message ol {
            margin: 8px 0;
            padding-left: 24px;
        }

        .message li {
            margin: 4px 0;
            line-height: 1.6;
        }

        .message blockquote {
            border-left: 3px solid var(--primary-cyan);
            padding-left: 16px;
            margin: 12px 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .message table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            font-size: 0.9em;
        }

        .message table th,
        .message table td {
            border: 1px solid rgba(148, 163, 184, 0.3);
            padding: 8px 12px;
            text-align: left;
        }

        .message table th {
            background: rgba(0, 212, 255, 0.1);
            font-weight: 600;
            color: var(--primary-cyan);
        }

        .message table tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.2);
        }

        .message h1,
        .message h2,
        .message h3,
        .message h4,
        .message h5,
        .message h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            line-height: 1.3;
        }

        .message h1 { font-size: 1.8em; color: var(--primary-cyan); }
        .message h2 { font-size: 1.5em; color: var(--primary-cyan); }
        .message h3 { font-size: 1.3em; }
        .message h4 { font-size: 1.1em; }
        .message h5 { font-size: 1em; }
        .message h6 { font-size: 0.9em; }

        .message h1:first-child,
        .message h2:first-child,
        .message h3:first-child,
        .message h4:first-child,
        .message h5:first-child,
        .message h6:first-child {
            margin-top: 0;
        }

        .message hr {
            border: none;
            border-top: 1px solid rgba(148, 163, 184, 0.3);
            margin: 16px 0;
        }

        .message strong {
            font-weight: 700;
            color: var(--text-primary);
        }

        .message em {
            font-style: italic;
            color: var(--text-secondary);
        }

        .message img {
            max-width: 100%;
            border-radius: 8px;
            margin: 12px 0;
        }

        /* Code language label */
        .message pre::before {
            content: attr(data-language);
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            scroll-behavior: smooth;
        }

        .chat-area::-webkit-scrollbar {
            width: 8px;
        }

        .chat-area::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-area::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        .chat-area::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        /* Messages */
        .message {
            padding: 18px 24px;
            border-radius: 16px;
            max-width: 75%;
            word-wrap: break-word;
            line-height: 1.6;
            animation: slideIn 0.3s ease-out;
            position: relative;
            font-size: 15px;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 153, 204, 0.2));
            align-self: flex-end;
            margin-left: auto;
            border: 1px solid rgba(0, 212, 255, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.15);
        }

        .message.assistant {
            background: var(--glass-bg);
            align-self: flex-start;
            border: 1px solid rgba(148, 163, 184, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .message.assistant::before {
            content: 'Ko2';
            position: absolute;
            top: -8px;
            left: 12px;
            font-size: 10px;
            font-weight: 700;
            color: var(--primary-cyan);
            background: var(--darker-bg);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            letter-spacing: 1px;
        }

        .message.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.2));
            align-self: center;
            max-width: 100%;
            border: 1px solid rgba(239, 68, 68, 0.4);
            color: #fecaca;
            backdrop-filter: blur(10px);
        }

        /* Message Edit Button */
        .message-content {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .edit-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.4);
            color: var(--primary-cyan);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 10;
        }

        .message.user:hover .edit-btn {
            opacity: 1;
        }

        .edit-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: scale(1.1);
        }

        /* Edit Mode */
        .message.editing {
            padding: 12px;
        }

        .message.editing .message-content {
            display: none;
        }

        .edit-mode {
            display: none;
            flex-direction: column;
            gap: 12px;
        }

        .message.editing .edit-mode {
            display: flex;
        }

        .edit-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            resize: vertical;
            outline: none;
            transition: all 0.3s ease;
            font-family: inherit;
            line-height: 1.6;
        }

        .edit-textarea:focus {
            border-color: var(--primary-cyan);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }

        .edit-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .edit-actions button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .edit-cancel-btn {
            background: rgba(148, 163, 184, 0.2);
            color: var(--text-primary);
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .edit-cancel-btn:hover {
            background: rgba(148, 163, 184, 0.3);
        }

        .edit-save-btn {
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            color: white;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
        }

        .edit-save-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
        }

        .edit-save-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Typing Indicator */
        .typing-indicator {
            background: var(--glass-bg);
            padding: 18px 24px;
            border-radius: 16px;
            max-width: 75%;
            display: none;
            border: 1px solid rgba(148, 163, 184, 0.2);
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease-out;
        }

        .typing-indicator.active {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--primary-cyan);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
        }

        .typing-indicator span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: translateY(0) scale(1);
            }
            40% {
                transform: translateY(-12px) scale(1.1);
            }
        }

        /* Input Area */
        .input-area {
            padding: 20px 30px 30px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(0, 212, 255, 0.2);
        }

        .input-container {
            display: flex;
            gap: 12px;
            max-width: 100%;
            position: relative;
        }

        #message-input {
            flex: 1;
            padding: 16px 20px;
            background: var(--glass-bg);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 15px;
            resize: none;
            outline: none;
            font-family: inherit;
            max-height: 200px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #message-input:focus {
            border-color: var(--primary-cyan);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1), 0 0 20px rgba(0, 212, 255, 0.2);
        }

        #message-input::placeholder {
            color: var(--text-secondary);
        }

        #send-button {
            padding: 16px 28px;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        #send-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        #send-button:hover::before {
            width: 300px;
            height: 300px;
        }

        #send-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
        }

        #send-button:active:not(:disabled) {
            transform: translateY(0);
        }

        #send-button:disabled {
            background: rgba(148, 163, 184, 0.3);
            cursor: not-allowed;
            box-shadow: none;
        }

        #send-button span {
            position: relative;
            z-index: 1;
        }

        /* API Key Modal */
        .api-key-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.3);
            border: 1px solid rgba(0, 212, 255, 0.3);
            animation: slideUp 0.4s ease-out;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            padding: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .modal-logo img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .modal-content h2 {
            margin-bottom: 12px;
            font-size: 28px;
            text-align: center;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal-content p {
            margin-bottom: 24px;
            color: var(--text-secondary);
            line-height: 1.6;
            text-align: center;
        }

        .modal-content input {
            width: 100%;
            padding: 16px 20px;
            background: var(--glass-bg);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 15px;
            margin-bottom: 20px;
            outline: none;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .modal-content input:focus {
            border-color: var(--primary-cyan);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }

        .modal-content button {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--primary-cyan), var(--secondary-blue));
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
        }

        .help-text {
            margin-top: 16px;
            font-size: 13px;
            color: var(--text-secondary);
            text-align: center;
        }

        .help-text code {
            background: var(--glass-bg);
            padding: 4px 8px;
            border-radius: 6px;
            color: var(--primary-cyan);
            font-family: 'Courier New', monospace;
        }

        .help-text a {
            color: var(--primary-cyan);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .help-text a:hover {
            color: var(--secondary-blue);
            text-decoration: underline;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--card-bg);
            backdrop-filter: blur(20px);
            padding: 16px 24px;
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
            z-index: 10000;
            min-width: 250px;
            max-width: 400px;
            animation: toastSlideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }

        .toast.error {
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);
        }

        .toast.success {
            border-color: rgba(16, 185, 129, 0.4);
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(100px);
            }
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #send-button.loading span {
            display: none;
        }

        #send-button.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            z-index: 2;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 16px 20px;
            }

            .logo {
                width: 40px;
                height: 40px;
            }

            .header h1 {
                font-size: 20px;
            }

            .header-subtitle {
                font-size: 10px;
            }

            .header-right {
                flex-direction: column;
                gap: 8px;
                align-items: flex-end;
            }

            .model-toggle-container {
                padding: 6px 12px;
                gap: 8px;
            }

            .model-label {
                font-size: 11px;
                min-width: auto;
            }

            .model-cost {
                font-size: 10px;
            }

            .credit-badge {
                font-size: 12px;
                padding: 8px 16px;
            }

            .message {
                max-width: 85%;
                padding: 14px 18px;
                font-size: 14px;
            }

            .chat-area {
                padding: 20px 16px;
            }

            .input-area {
                padding: 16px 20px;
            }

            #send-button {
                padding: 16px 20px;
                font-size: 14px;
            }

            .modal-content {
                padding: 30px 24px;
            }

            .modal-logo {
                width: 60px;
                height: 60px;
            }

            .memories-section {
                padding: 12px 16px;
            }

            .memories-list {
                max-height: 150px;
            }

            .memory-item {
                padding: 8px 10px;
            }

            .memory-content {
                font-size: 11px;
            }

            .add-memory-modal .modal-content {
                padding: 24px 20px;
            }

            .memory-input-footer {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }

            .command-palette-content {
                top: 10%;
                width: 95%;
                max-width: none;
            }

            #command-search-input {
                font-size: 16px;
            }

            .command-list {
                max-height: 300px;
            }

            .command-footer {
                font-size: 10px;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="bg-animation">
        <div class="particles" id="particles"></div>
    </div>

    <!-- Sidebar Backdrop for Mobile -->
    <div class="sidebar-backdrop" id="sidebar-backdrop"></div>

    <div class="main-wrapper">
        <!-- Sidebar for Conversations -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" id="new-chat-btn">
                    + New Chat
                </button>
            </div>

            <!-- Memories Section -->
            <div class="memories-section">
                <div class="memories-header" id="memories-header">
                    <span class="memories-title">ðŸ§  Memories</span>
                    <span class="memory-count-badge" id="memory-count-badge">0/10</span>
                </div>
                <button class="add-memory-btn" id="add-memory-btn">
                    + Add Memory
                </button>
                <div class="memories-list" id="memories-list">
                    <!-- Memories will be loaded here -->
                </div>
            </div>

            <div class="conversations-list" id="conversations-list">
                <!-- Conversations will be loaded here -->
            </div>
        </div>

        <!-- Main Chat Container -->
        <div class="container">
            <div class="header">
                <div class="header-left">
                    <button class="menu-toggle" id="menu-toggle">â˜°</button>
                    <div class="logo">
                        <img src="/static/ko2-logo.png" alt="Ko2">
                    </div>
                    <div class="header-title">
                        <h1>Ko2</h1>
                        <div class="header-subtitle">Unrestricted Intelligence</div>
                    </div>
                </div>
                <div class="header-right">
                    <div class="model-toggle-container">
                        <span class="model-label" id="model-label">DeepSeek <span class="model-cost">(1 cr/msg)</span></span>
                        <div class="model-toggle" id="model-toggle"></div>
                    </div>
                    <div class="credit-badge" id="credit-badge">Credits: --</div>
                </div>
            </div>

        <div class="chat-area" id="chat-area">
            <div class="message assistant">
                Welcome to Ko2. I'm your unrestricted AI assistant - no limitations, no boundaries. What would you like to explore?
            </div>
        </div>

        <div class="typing-indicator" id="typing-indicator">
            <span></span><span></span><span></span>
        </div>

        <div class="input-area">
            <div class="input-container">
                <textarea 
                    id="message-input" 
                    placeholder="Ask anything... no limits." 
                    rows="1"
                    maxlength="4000"
                ></textarea>
                <button id="send-button"><span>Send</span></button>
            </div>
        </div>
    </div>

    <div class="api-key-modal" id="api-key-modal">
        <div class="modal-content">
            <div class="modal-logo">
                <img src="/static/ko2-logo.png" alt="Ko2">
            </div>
            <h2>Access Ko2</h2>
            <p>Enter your API key to unlock unrestricted AI capabilities.</p>
            <input 
                type="text" 
                id="api-key-input" 
                placeholder="API Key..."
                autocomplete="off"
            />
            <button id="save-api-key">Unlock Access</button>
            <p class="help-text">
                Get your API key from Telegram: <code>/getapikey</code>
            </p>
        </div>
    </div>

    <!-- Add Memory Modal -->
    <div class="add-memory-modal" id="add-memory-modal" style="display: none;">
        <div class="modal-content">
            <h2>Add Memory</h2>
            <p>What should I remember about you?</p>
            <textarea
                id="memory-content-input"
                placeholder="e.g., I prefer dark themes and love cats"
                maxlength="200"
                rows="3"
            ></textarea>
            <div class="memory-input-footer">
                <span class="char-counter" id="char-counter">0/200</span>
                <span class="slots-remaining" id="slots-remaining">10 slots remaining</span>
            </div>
            <div class="modal-buttons">
                <button id="cancel-memory-btn" class="cancel-btn">Cancel</button>
                <button id="save-memory-btn" class="save-btn">Save Memory</button>
            </div>
        </div>
    </div>

    <!-- Command Palette -->
    <div class="command-palette" id="command-palette" style="display: none;">
        <div class="command-palette-backdrop"></div>
        <div class="command-palette-content">
            <div class="command-search">
                <span class="search-icon">ðŸ”</span>
                <input
                    type="text"
                    placeholder="Type a command or search..."
                    id="command-search-input"
                    autocomplete="off"
                    spellcheck="false"
                />
                <button class="command-close-btn" id="command-close-btn">âœ•</button>
            </div>
            <div class="command-list" id="command-list">
                <!-- Commands will be rendered here -->
            </div>
            <div class="command-footer">
                <span><kbd>â†‘</kbd><kbd>â†“</kbd> Navigate</span>
                <span><kbd>Enter</kbd> Execute</span>
                <span><kbd>Esc</kbd> Close</span>
            </div>
        </div>
    </div>

    <script>
        // Create floating particles
        const particlesContainer = document.getElementById('particles');
        for (let i = 0; i < 30; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            particlesContainer.appendChild(particle);
        }

        // Configure marked.js with syntax highlighting
        marked.setOptions({
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {
                        console.error('Highlight error:', err);
                    }
                }
                return hljs.highlightAuto(code).value;
            },
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });

        // Custom renderer to add language labels to code blocks
        const renderer = new marked.Renderer();
        const originalCodeRenderer = renderer.code.bind(renderer);
        renderer.code = function(code, language) {
            const html = originalCodeRenderer(code, language);
            const langLabel = language || 'text';
            return html.replace('<pre>', `<pre data-language="${langLabel}">`);
        };
        marked.use({ renderer });

        const API_ENDPOINT = '/v1/chat/completions';
        let apiKey = localStorage.getItem('uncensored_ai_api_key') || '';
        let conversationHistory = [];
        let currentConversationId = null;
        let conversations = [];
        let currentModel = 'deepseek'; // Default model

        const chatArea = document.getElementById('chat-area');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const apiKeyModal = document.getElementById('api-key-modal');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key');
        const creditBadge = document.getElementById('credit-badge');
        const conversationsList = document.getElementById('conversations-list');
        const newChatBtn = document.getElementById('new-chat-btn');
        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const modelToggle = document.getElementById('model-toggle');
        const modelLabel = document.getElementById('model-label');

        // Memory elements
        const memoriesList = document.getElementById('memories-list');
        const memoryCountBadge = document.getElementById('memory-count-badge');
        const addMemoryBtn = document.getElementById('add-memory-btn');
        const addMemoryModal = document.getElementById('add-memory-modal');
        const memoryContentInput = document.getElementById('memory-content-input');
        const saveMemoryBtn = document.getElementById('save-memory-btn');
        const cancelMemoryBtn = document.getElementById('cancel-memory-btn');
        const charCounter = document.getElementById('char-counter');
        const slotsRemaining = document.getElementById('slots-remaining');

        let memories = [];
        let maxMemories = 10;

        // Defensive check for menu toggle
        if (!menuToggle) {
            console.error('Menu toggle button not found');
        }

        // Show/hide API key modal and load conversations
        if (!apiKey) {
            apiKeyModal.style.display = 'flex';
        } else {
            apiKeyModal.style.display = 'none';
            updateCreditBalance();
            loadConversations();
            loadModelSettings();
            loadMemories();
        }

        // Fetch and display current model settings
        async function loadModelSettings() {
            if (!apiKey) return;

            try {
                const response = await fetch('/api/settings', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    currentModel = data.preferred_model || 'deepseek';
                    updateModelUI();
                } else {
                    console.error('Failed to fetch model settings');
                }
            } catch (error) {
                console.error('Error fetching model settings:', error);
            }
        }

        // Update model UI based on current selection
        function updateModelUI() {
            if (currentModel === 'gpt4o') {
                modelToggle.classList.add('active');
                modelLabel.innerHTML = 'GPT-4o <span class="model-cost">(3 cr/msg)</span>';
            } else {
                modelToggle.classList.remove('active');
                modelLabel.innerHTML = 'DeepSeek <span class="model-cost">(1 cr/msg)</span>';
            }
        }

        // Handle model toggle click
        modelToggle.addEventListener('click', async () => {
            const newModel = currentModel === 'deepseek' ? 'gpt4o' : 'deepseek';

            try {
                const response = await fetch('/api/settings', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        preferred_model: newModel
                    })
                });

                if (response.ok) {
                    currentModel = newModel;
                    updateModelUI();
                    showToast(`Switched to ${newModel === 'gpt4o' ? 'GPT-4o (3 credits/msg)' : 'DeepSeek (1 credit/msg)'}`, 'success');
                } else {
                    const error = await response.json();
                    showToast('Failed to update model: ' + (error.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Error updating model:', error);
                showToast('Failed to update model. Please try again.', 'error');
            }
        });

        // ===== MEMORY MANAGEMENT FUNCTIONS =====

        // Load memories from API
        async function loadMemories() {
            if (!apiKey) return;

            try {
                const response = await fetch('/api/memories', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    memories = data.memories || [];
                    maxMemories = data.max_allowed || 10;
                    renderMemories();
                } else {
                    console.error('Failed to load memories');
                }
            } catch (error) {
                console.error('Error loading memories:', error);
            }
        }

        // Render memories in UI
        function renderMemories() {
            const count = memories.length;
            memoryCountBadge.textContent = `${count}/${maxMemories}`;

            // Update add button state
            if (count >= maxMemories) {
                addMemoryBtn.disabled = true;
                addMemoryBtn.title = 'Maximum memories reached';
            } else {
                addMemoryBtn.disabled = false;
                addMemoryBtn.title = '';
            }

            // Clear list
            memoriesList.innerHTML = '';

            if (memories.length === 0) {
                memoriesList.innerHTML = '<div class="memories-empty">No memories yet. Add one to get started!</div>';
                return;
            }

            // Render each memory
            memories.forEach(memory => {
                const memoryDiv = document.createElement('div');
                memoryDiv.className = 'memory-item';
                memoryDiv.dataset.id = memory.id;

                const date = new Date(memory.created_at);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

                memoryDiv.innerHTML = `
                    <div class="memory-content">${escapeHtml(memory.content)}</div>
                    <div class="memory-footer">
                        <span class="memory-date">${dateStr}</span>
                        <button class="memory-delete-btn" onclick="confirmDeleteMemory(${memory.id})">Delete</button>
                    </div>
                `;

                memoriesList.appendChild(memoryDiv);
            });
        }

        // Open add memory modal
        function openAddMemoryModal() {
            const slotsLeft = maxMemories - memories.length;
            slotsRemaining.textContent = `${slotsLeft} ${slotsLeft === 1 ? 'slot' : 'slots'} remaining`;
            memoryContentInput.value = '';
            charCounter.textContent = '0/200';
            saveMemoryBtn.disabled = true;
            addMemoryModal.style.display = 'flex';
            setTimeout(() => memoryContentInput.focus(), 100);
        }

        // Close add memory modal
        function closeAddMemoryModal() {
            addMemoryModal.style.display = 'none';
            memoryContentInput.value = '';
        }

        // Add new memory
        async function addMemory() {
            const content = memoryContentInput.value.trim();
            if (!content || !apiKey) return;

            // Disable button during save
            saveMemoryBtn.disabled = true;
            saveMemoryBtn.textContent = 'Saving...';

            try {
                const response = await fetch('/api/memories', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({ content })
                });

                if (response.ok) {
                    const newMemory = await response.json();
                    memories.unshift(newMemory); // Add to beginning
                    renderMemories();
                    closeAddMemoryModal();
                    showToast('Memory saved successfully!', 'success');
                } else {
                    const error = await response.json();
                    showToast(error.error || 'Failed to save memory', 'error');
                    saveMemoryBtn.disabled = false;
                    saveMemoryBtn.textContent = 'Save Memory';
                }
            } catch (error) {
                console.error('Error adding memory:', error);
                showToast('Failed to save memory. Please try again.', 'error');
                saveMemoryBtn.disabled = false;
                saveMemoryBtn.textContent = 'Save Memory';
            }
        }

        // Confirm and delete memory
        async function confirmDeleteMemory(memoryId) {
            const memory = memories.find(m => m.id === memoryId);
            if (!memory) return;

            if (!confirm(`Delete this memory?\n\n"${memory.content}"\n\nThis cannot be undone.`)) {
                return;
            }

            await deleteMemory(memoryId);
        }

        // Delete memory
        async function deleteMemory(memoryId) {
            try {
                const response = await fetch(`/api/memories/${memoryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    // Remove from local array
                    memories = memories.filter(m => m.id !== memoryId);
                    renderMemories();
                    showToast('Memory deleted successfully', 'success');
                } else {
                    showToast('Failed to delete memory', 'error');
                }
            } catch (error) {
                console.error('Error deleting memory:', error);
                showToast('Failed to delete memory. Please try again.', 'error');
            }
        }

        // Update character counter
        memoryContentInput.addEventListener('input', () => {
            const length = memoryContentInput.value.length;
            charCounter.textContent = `${length}/200`;
            saveMemoryBtn.disabled = length === 0 || length > 200;
        });

        // Event listeners for memory modal
        addMemoryBtn.addEventListener('click', openAddMemoryModal);
        saveMemoryBtn.addEventListener('click', addMemory);
        cancelMemoryBtn.addEventListener('click', closeAddMemoryModal);

        // Close modal on Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && addMemoryModal.style.display === 'flex') {
                closeAddMemoryModal();
            }
        });

        // Allow Enter to save memory (Shift+Enter for new line)
        memoryContentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !saveMemoryBtn.disabled) {
                e.preventDefault();
                addMemory();
            }
        });

        // HTML escape helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Make confirmDeleteMemory globally accessible
        window.confirmDeleteMemory = confirmDeleteMemory;

        // ===== END MEMORY MANAGEMENT =====

        // ===== COMMAND PALETTE =====

        const commandPalette = document.getElementById('command-palette');
        const commandSearchInput = document.getElementById('command-search-input');
        const commandList = document.getElementById('command-list');
        const commandCloseBtn = document.getElementById('command-close-btn');

        let commandPaletteOpen = false;
        let selectedCommandIndex = 0;
        let filteredCommands = [];
        let allCommands = [];

        // Command registry
        function initializeCommands() {
            allCommands = [
                // Chat Management
                {
                    id: 'new-chat',
                    label: 'New Chat',
                    icon: 'ðŸ’¬',
                    shortcut: '',
                    category: 'Chat',
                    action: () => createNewConversation(),
                    keywords: ['new', 'chat', 'conversation', 'start', 'create']
                },
                {
                    id: 'delete-conversation',
                    label: 'Delete Current Conversation',
                    icon: 'ðŸ—‘ï¸',
                    shortcut: '',
                    category: 'Chat',
                    action: () => {
                        if (currentConversationId) {
                            deleteConversation(currentConversationId);
                        } else {
                            showToast('No conversation selected', 'error');
                        }
                    },
                    keywords: ['delete', 'remove', 'conversation', 'chat']
                },

                // Memory Management
                {
                    id: 'add-memory',
                    label: 'Add Memory',
                    icon: 'ðŸ§ ',
                    shortcut: '',
                    category: 'Memory',
                    action: () => openAddMemoryModal(),
                    keywords: ['add', 'memory', 'remember', 'save', 'store']
                },

                // AI Features
                {
                    id: 'switch-model',
                    label: 'Switch Model',
                    icon: 'ðŸ¤–',
                    get description() {
                        return `Currently: ${currentModel === 'gpt4o' ? 'GPT-4o' : 'DeepSeek'}`;
                    },
                    category: 'AI',
                    action: () => modelToggle.click(),
                    keywords: ['model', 'switch', 'toggle', 'deepseek', 'gpt4o', 'gpt-4o', 'change']
                },

                // Account
                {
                    id: 'buy-credits',
                    label: 'Buy Credits',
                    icon: 'ðŸ’°',
                    shortcut: '',
                    category: 'Account',
                    action: () => {
                        if (apiKey) {
                            fetch('/api/balance', {
                                headers: { 'Authorization': `Bearer ${apiKey}` }
                            }).then(res => res.json()).then(data => {
                                const user = data; // Simplified - would need telegram_id
                                window.open(`/buy?telegram_id=`, '_blank');
                            });
                        }
                    },
                    keywords: ['buy', 'purchase', 'credits', 'payment', 'pay']
                },
                {
                    id: 'view-credits',
                    label: 'View Credit Balance',
                    icon: 'ðŸ’³',
                    shortcut: '',
                    category: 'Account',
                    action: () => {
                        updateCreditBalance();
                        showToast('Balance refreshed', 'success');
                    },
                    keywords: ['credits', 'balance', 'view', 'check']
                },

                // Navigation
                {
                    id: 'focus-input',
                    label: 'Focus Message Input',
                    icon: 'âœï¸',
                    shortcut: '/',
                    category: 'Navigation',
                    action: () => messageInput.focus(),
                    keywords: ['focus', 'input', 'message', 'type', 'chat']
                },
                {
                    id: 'toggle-sidebar',
                    label: 'Toggle Sidebar',
                    icon: 'ðŸ“±',
                    shortcut: '',
                    category: 'Navigation',
                    action: () => {
                        sidebar.classList.toggle('active');
                        sidebarBackdrop.classList.toggle('active');
                    },
                    keywords: ['sidebar', 'toggle', 'show', 'hide', 'menu']
                },

                // Help
                {
                    id: 'telegram-bot',
                    label: 'Open Telegram Bot',
                    icon: 'âœˆï¸',
                    shortcut: '',
                    category: 'Help',
                    action: () => window.open('https://t.me/UnboundGPT_bot', '_blank'),
                    keywords: ['telegram', 'bot', 'open', 'mobile']
                },
                {
                    id: 'get-api-key',
                    label: 'Get API Key',
                    icon: 'ðŸ”‘',
                    description: 'Use /getapikey on Telegram',
                    category: 'Help',
                    action: () => {
                        showToast('Use /getapikey command on Telegram bot', 'info');
                    },
                    keywords: ['api', 'key', 'getapikey', 'auth']
                }
            ];
        }

        // Open command palette
        function openCommandPalette() {
            commandPalette.style.display = 'flex';
            commandSearchInput.value = '';
            commandPaletteOpen = true;
            selectedCommandIndex = 0;
            initializeCommands();
            filteredCommands = [...allCommands];
            renderCommands();
            setTimeout(() => commandSearchInput.focus(), 50);
        }

        // Close command palette
        function closeCommandPalette() {
            commandPalette.style.display = 'none';
            commandPaletteOpen = false;
            selectedCommandIndex = 0;
        }

        // Execute command
        function executeCommand(command) {
            closeCommandPalette();
            try {
                command.action();
            } catch (error) {
                console.error('Error executing command:', error);
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // Fuzzy search algorithm
        function fuzzySearch(query, commands) {
            if (!query) return commands;

            const lowerQuery = query.toLowerCase();

            return commands
                .map(cmd => {
                    const text = `${cmd.label} ${cmd.keywords.join(' ')}`.toLowerCase();
                    const description = (typeof cmd.description === 'function' ? cmd.description() : cmd.description || '').toLowerCase();
                    const searchText = `${text} ${description}`;

                    let score = 0;
                    if (text === lowerQuery) score = 100;
                    else if (text.startsWith(lowerQuery)) score = 80;
                    else if (text.includes(lowerQuery)) score = 60;
                    else {
                        // Fuzzy match
                        let queryIndex = 0;
                        for (let char of searchText) {
                            if (char === lowerQuery[queryIndex]) queryIndex++;
                            if (queryIndex === lowerQuery.length) {
                                score = 40;
                                break;
                            }
                        }
                    }

                    return { ...cmd, score };
                })
                .filter(cmd => cmd.score > 0)
                .sort((a, b) => b.score - a.score);
        }

        // Render commands
        function renderCommands() {
            commandList.innerHTML = '';

            if (filteredCommands.length === 0) {
                commandList.innerHTML = '<div class="command-empty">No commands found</div>';
                return;
            }

            // Group by category
            const categories = {};
            filteredCommands.forEach(cmd => {
                if (!categories[cmd.category]) {
                    categories[cmd.category] = [];
                }
                categories[cmd.category].push(cmd);
            });

            // Render each category
            Object.keys(categories).forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'command-category';
                categoryDiv.textContent = category;
                commandList.appendChild(categoryDiv);

                categories[category].forEach((cmd, index) => {
                    const globalIndex = filteredCommands.indexOf(cmd);
                    const cmdDiv = document.createElement('div');
                    cmdDiv.className = 'command-item';
                    if (globalIndex === selectedCommandIndex) {
                        cmdDiv.classList.add('selected');
                    }
                    cmdDiv.dataset.index = globalIndex;

                    const description = typeof cmd.description === 'function' ? cmd.description() : cmd.description;

                    cmdDiv.innerHTML = `
                        <div class="command-icon">${cmd.icon}</div>
                        <div class="command-details">
                            <div class="command-label">${escapeHtml(cmd.label)}</div>
                            ${description ? `<div class="command-description">${escapeHtml(description)}</div>` : ''}
                        </div>
                        ${cmd.shortcut ? `<div class="command-shortcut">${escapeHtml(cmd.shortcut)}</div>` : ''}
                    `;

                    cmdDiv.addEventListener('click', () => executeCommand(cmd));
                    commandList.appendChild(cmdDiv);
                });
            });

            // Scroll selected into view
            scrollSelectedCommandIntoView();
        }

        // Scroll selected command into view
        function scrollSelectedCommandIntoView() {
            const selectedEl = commandList.querySelector('.command-item.selected');
            if (selectedEl) {
                selectedEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }

        // Search input handler
        commandSearchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            filteredCommands = fuzzySearch(query, allCommands);
            selectedCommandIndex = 0;
            renderCommands();
        });

        // Keyboard navigation
        commandSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedCommandIndex = Math.min(selectedCommandIndex + 1, filteredCommands.length - 1);
                renderCommands();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
                renderCommands();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (filteredCommands[selectedCommandIndex]) {
                    executeCommand(filteredCommands[selectedCommandIndex]);
                }
            } else if (e.key === 'Escape') {
                closeCommandPalette();
            }
        });

        // Close button
        commandCloseBtn.addEventListener('click', closeCommandPalette);

        // Close on backdrop click
        commandPalette.addEventListener('click', (e) => {
            if (e.target === commandPalette || e.target.classList.contains('command-palette-backdrop')) {
                closeCommandPalette();
            }
        });

        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+K or Cmd+K to open command palette
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (!commandPaletteOpen) {
                    openCommandPalette();
                }
            }

            // Ctrl+Shift+P or Cmd+Shift+P alternative
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
                e.preventDefault();
                if (!commandPaletteOpen) {
                    openCommandPalette();
                }
            }

            // Escape to close command palette (if not already handled)
            if (e.key === 'Escape' && commandPaletteOpen) {
                if (document.activeElement !== commandSearchInput) {
                    closeCommandPalette();
                }
            }
        });

        // ===== END COMMAND PALETTE =====

        // Command Palette FAB Button Handler
        const commandPaletteFab = document.getElementById('command-palette-fab');
        if (commandPaletteFab) {
            commandPaletteFab.addEventListener('click', openCommandPalette);
        }

        // Toast notification function
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'toastSlideOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        // Save API key
        saveApiKeyButton.addEventListener('click', async () => {
            const key = apiKeyInput.value.trim();
            if (!key) {
                showToast('Please enter a valid API key', 'error');
                return;
            }

            // Disable button and show loading state
            saveApiKeyButton.disabled = true;
            const originalText = saveApiKeyButton.textContent;
            saveApiKeyButton.textContent = 'Validating...';

            try {
                // Validate API key by testing it with the balance endpoint
                console.log('Validating API key...');
                const response = await fetch('/api/balance', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${key}`
                    }
                });

                console.log('Validation response status:', response.status);

                if (response.ok) {
                    // Key is valid - save it
                    console.log('API key validated successfully');
                    apiKey = key;
                    localStorage.setItem('uncensored_ai_api_key', key);
                    apiKeyModal.style.display = 'none';

                    // Load user data
                    updateCreditBalance();
                    loadConversations();
                    loadModelSettings();
                    loadMemories();

                    showToast('API key saved successfully!', 'success');
                } else if (response.status === 401) {
                    // Invalid API key
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Invalid API key:', errorData);
                    showToast('Invalid API key. Get yours from Telegram: /getapikey', 'error');
                    apiKeyInput.value = '';
                    apiKeyInput.focus();
                } else if (response.status === 503) {
                    // Database unavailable
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Database unavailable:', errorData);
                    showToast('Database temporarily unavailable. Try again in a moment.', 'error');
                } else {
                    // Other error
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Validation error:', response.status, errorData);
                    showToast(`Error validating API key (${response.status}). Please try again.`, 'error');
                }
            } catch (error) {
                console.error('Error validating API key:', error);
                showToast('Network error. Please check your connection.', 'error');
            } finally {
                // Re-enable button
                saveApiKeyButton.disabled = false;
                saveApiKeyButton.textContent = originalText;
            }
        });

        // New chat button
        newChatBtn.addEventListener('click', createNewConversation);

        // Mobile menu toggle
        if (menuToggle) {
            menuToggle.addEventListener('click', () => {
                sidebar.classList.toggle('active');
                sidebarBackdrop.classList.toggle('active');
            });
        }

        // Close sidebar when clicking backdrop
        if (sidebarBackdrop) {
            sidebarBackdrop.addEventListener('click', () => {
                sidebar.classList.remove('active');
                sidebarBackdrop.classList.remove('active');
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Escape to close sidebar
            if (e.key === 'Escape') {
                if (sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                    sidebarBackdrop.classList.remove('active');
                }
            }
            
            // Ctrl+K for new chat
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                createNewConversation();
            }
        });

        // Allow Enter to save API key
        apiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveApiKeyButton.click();
            }
        });

        // Auto-resize textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });

        // Send message on Enter (Shift+Enter for new line)
        messageInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                await sendMessage();
            }
        });

        sendButton.addEventListener('click', sendMessage);

        async function updateCreditBalance() {
            if (!apiKey) {
                creditBadge.textContent = 'Credits: --';
                return;
            }

            try {
                const response = await fetch('/api/balance', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    creditBadge.textContent = `Credits: ${data.total_credits}`;
                } else {
                    creditBadge.textContent = 'Credits: --';
                }
            } catch (error) {
                console.error('Failed to fetch balance:', error);
                creditBadge.textContent = 'Credits: --';
            }
        }

        async function loadConversations() {
            if (!apiKey) return;

            try {
                const response = await fetch('/api/conversations', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    conversations = data.conversations || [];
                    
                    renderConversations();
                    
                    // Select first conversation or create one if none exist
                    if (conversations.length > 0) {
                        switchConversation(conversations[0].id);
                    } else {
                        // Auto-create first conversation
                        await createNewConversation();
                    }
                } else if (response.status === 401) {
                    console.error('Invalid API key');
                    localStorage.removeItem('uncensored_ai_api_key');
                    location.reload();
                }
            } catch (error) {
                console.error('Failed to load conversations:', error);
            }
        }

        function renderConversations() {
            conversationsList.innerHTML = '';
            
            conversations.forEach(conv => {
                const convDiv = document.createElement('div');
                convDiv.className = 'conversation-item';
                if (conv.id === currentConversationId) {
                    convDiv.classList.add('active');
                }
                
                convDiv.innerHTML = `
                    <div class="conversation-title">${conv.title}</div>
                    <div class="conversation-meta">
                        <span>${conv.message_count} messages</span>
                    </div>
                    <button class="delete-conversation-btn" onclick="event.stopPropagation(); deleteConversation(${conv.id})">
                        Delete
                    </button>
                `;
                
                convDiv.onclick = () => switchConversation(conv.id);
                conversationsList.appendChild(convDiv);
            });
        }

        async function createNewConversation() {
            if (!apiKey) {
                console.error('No API key available');
                return;
            }

            try {
                console.log('Creating new conversation...');
                const response = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        title: 'New Chat'
                    })
                });

                console.log('Response status:', response.status);

                if (response.ok) {
                    const newConv = await response.json();
                    console.log('Created new conversation:', newConv);
                    conversations.unshift(newConv);
                    renderConversations();
                    await switchConversation(newConv.id);
                    showToast('New chat created!', 'success');
                } else {
                    const error = await response.json();
                    console.error('Failed to create conversation:', error);
                    showToast('Failed to create new chat: ' + (error.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                console.error('Failed to create conversation:', error);
                showToast('Failed to create new chat. Please try again.', 'error');
            }
        }

        async function switchConversation(conversationId) {
            currentConversationId = conversationId;
            renderConversations();
            
            // Clear chat area and load messages for this conversation
            chatArea.innerHTML = '';
            conversationHistory = [];
            
            await loadMessageHistory(conversationId);
            
            // Close sidebar on mobile after switching
            sidebar.classList.remove('active');
            sidebarBackdrop.classList.remove('active');
        }

        async function deleteConversation(conversationId) {
            // Find conversation details for better confirmation
            const conv = conversations.find(c => c.id === conversationId);
            const convTitle = conv ? conv.title : 'this conversation';
            const msgCount = conv ? conv.message_count : 0;
            
            if (!confirm(`Delete "${convTitle}" (${msgCount} messages)?\n\nThis cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch(`/api/conversations/${conversationId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    showToast('Conversation deleted', 'success');
                    // Remove from local array
                    conversations = conversations.filter(c => c.id !== conversationId);
                    renderConversations();
                    
                    // If deleted current conversation, switch to another
                    if (conversationId === currentConversationId) {
                        if (conversations.length > 0) {
                            switchConversation(conversations[0].id);
                        } else {
                            // Create new conversation if none left
                            await createNewConversation();
                        }
                    }
                } else {
                    showToast('Failed to delete conversation', 'error');
                }
            } catch (error) {
                console.error('Failed to delete conversation:', error);
                showToast('Failed to delete conversation', 'error');
            }
        }

        async function loadMessageHistory(conversationId) {
            if (!apiKey || !conversationId) return;

            try {
                const response = await fetch(`/api/messages?conversation_id=${conversationId}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    const messages = data.messages || [];
                    
                    // Display all messages with their IDs
                    messages.forEach(msg => {
                        addMessage(msg.role, msg.content, msg.id);
                    });
                    
                    // Populate conversation history for context
                    conversationHistory = messages;
                    
                    console.log(`Loaded ${messages.length} messages from conversation ${conversationId}`);
                    scrollToBottom();
                } else if (response.status === 401) {
                    console.error('Invalid API key when loading messages');
                    localStorage.removeItem('uncensored_ai_api_key');
                    location.reload();
                }
            } catch (error) {
                console.error('Failed to load message history:', error);
            }
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || !apiKey) return;

            // Disable input and show loading state
            messageInput.disabled = true;
            sendButton.disabled = true;
            sendButton.classList.add('loading');

            // Add user message to chat
            addMessage('user', message);
            messageInput.value = '';
            messageInput.style.height = 'auto';

            // Add to conversation history
            conversationHistory.push({
                role: 'user',
                content: message
            });

            // Show typing indicator
            typingIndicator.classList.add('active');
            scrollToBottom();

            try {
                // Map currentModel to full model name
                const modelName = currentModel === 'gpt4o'
                    ? 'openai/chatgpt-4o-latest'
                    : 'deepseek/deepseek-chat-v3-0324';

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: conversationHistory,
                        stream: true,
                        conversation_id: currentConversationId
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'Request failed');
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantMessage = '';
                let messageElement = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data === '[DONE]') continue;

                            try {
                                const parsed = JSON.parse(data);
                                const content = parsed.choices?.[0]?.delta?.content;

                                if (content) {
                                    assistantMessage += content;

                                    // Create or update message element
                                    if (!messageElement) {
                                        typingIndicator.classList.remove('active');
                                        messageElement = addMessage('assistant', assistantMessage);
                                    } else {
                                        // Update with markdown rendering during streaming
                                        try {
                                            messageElement.innerHTML = marked.parse(assistantMessage);
                                        } catch (err) {
                                            messageElement.textContent = assistantMessage;
                                        }
                                    }

                                    scrollToBottom();
                                }
                            } catch (e) {
                                // Ignore parsing errors for incomplete chunks
                            }
                        }
                    }
                }

                // Add assistant response to history
                if (assistantMessage) {
                    conversationHistory.push({
                        role: 'assistant',
                        content: assistantMessage
                    });
                }

            } catch (error) {
                console.error('Error:', error);
                typingIndicator.classList.remove('active');
                
                if (error.message.includes('Invalid API key')) {
                    addMessage('error', 'âŒ Invalid API key. Get a new one from Telegram: /getapikey');
                    localStorage.removeItem('uncensored_ai_api_key');
                    apiKey = '';
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else if (error.message.includes('Insufficient credits')) {
                    addMessage('error', 'âŒ ' + error.message);
                } else {
                    addMessage('error', 'âŒ Error: ' + error.message);
                }
            } finally {
                // Re-enable input and remove loading state
                messageInput.disabled = false;
                sendButton.disabled = false;
                sendButton.classList.remove('loading');
                messageInput.focus();
                typingIndicator.classList.remove('active');
                
                // Update credit balance after message
                updateCreditBalance();
                
                // Reload conversations to get updated titles
                await loadConversations();
            }
        }

        function addMessage(type, content, messageId = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            if (messageId) {
                messageDiv.dataset.messageId = messageId;
            }

            // For user messages, add edit button and edit mode UI
            if (type === 'user') {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'message-content';
                contentWrapper.textContent = content;

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-btn';
                editBtn.innerHTML = 'âœï¸';
                editBtn.title = 'Edit message';
                editBtn.onclick = () => enterEditMode(messageDiv, content);
                contentWrapper.appendChild(editBtn);

                // Edit mode UI (hidden by default)
                const editMode = document.createElement('div');
                editMode.className = 'edit-mode';
                editMode.innerHTML = `
                    <textarea class="edit-textarea" rows="3">${escapeHtml(content)}</textarea>
                    <div class="edit-actions">
                        <button class="edit-cancel-btn">Cancel</button>
                        <button class="edit-save-btn">Save & Regenerate</button>
                    </div>
                `;

                messageDiv.appendChild(contentWrapper);
                messageDiv.appendChild(editMode);

                // Add event listeners
                const cancelBtn = editMode.querySelector('.edit-cancel-btn');
                const saveBtn = editMode.querySelector('.edit-save-btn');
                const textarea = editMode.querySelector('.edit-textarea');

                cancelBtn.onclick = () => exitEditMode(messageDiv);
                saveBtn.onclick = () => saveEditedMessage(messageDiv, textarea.value, messageId);

                // Auto-resize textarea
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = this.scrollHeight + 'px';
                });
            }
            // Render markdown for assistant messages
            else if (type === 'assistant') {
                try {
                    messageDiv.innerHTML = marked.parse(content);
                } catch (err) {
                    console.error('Markdown parse error:', err);
                    messageDiv.textContent = content;
                }
            }
            // Plain text for error messages
            else {
                messageDiv.textContent = content;
            }

            chatArea.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

        function enterEditMode(messageDiv, currentContent) {
            messageDiv.classList.add('editing');
            const textarea = messageDiv.querySelector('.edit-textarea');
            if (textarea) {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }
        }

        function exitEditMode(messageDiv) {
            messageDiv.classList.remove('editing');
        }

        async function saveEditedMessage(messageDiv, newContent, messageId) {
            newContent = newContent.trim();
            if (!newContent || !apiKey) return;

            const saveBtn = messageDiv.querySelector('.edit-save-btn');
            const originalText = saveBtn.textContent;
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                // Update message in backend and delete subsequent messages
                const response = await fetch(`/api/messages/${messageId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        content: newContent,
                        conversation_id: currentConversationId
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update message');
                }

                // Remove all messages after this one from UI
                let nextElement = messageDiv.nextElementSibling;
                while (nextElement) {
                    const toRemove = nextElement;
                    nextElement = nextElement.nextElementSibling;
                    if (toRemove.classList.contains('message')) {
                        toRemove.remove();
                    }
                }

                // Update the message content in UI
                const contentWrapper = messageDiv.querySelector('.message-content');
                if (contentWrapper) {
                    contentWrapper.childNodes[0].textContent = newContent;
                }

                // Exit edit mode
                exitEditMode(messageDiv);

                // Update conversation history - remove messages after this one
                const updatedHistory = [];
                for (let msg of conversationHistory) {
                    updatedHistory.push(msg);
                    if (msg.id === messageId) {
                        // Update this message's content
                        msg.content = newContent;
                        break;
                    }
                }
                conversationHistory = updatedHistory;

                // Re-send the message to get new AI response
                showToast('Message updated. Generating new response...', 'success');
                await resendFromEditedMessage(newContent);

            } catch (error) {
                console.error('Error editing message:', error);
                showToast('Failed to update message: ' + error.message, 'error');
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
            }
        }

        async function resendFromEditedMessage(messageContent) {
            // Disable input
            messageInput.disabled = true;
            sendButton.disabled = true;
            sendButton.classList.add('loading');

            // Show typing indicator
            typingIndicator.classList.add('active');
            scrollToBottom();

            try {
                // Map currentModel to full model name
                const modelName = currentModel === 'gpt4o'
                    ? 'openai/chatgpt-4o-latest'
                    : 'deepseek/deepseek-chat-v3-0324';

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: conversationHistory,
                        stream: true,
                        conversation_id: currentConversationId
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'Request failed');
                }

                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantMessage = '';
                let messageElement = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data === '[DONE]') continue;

                            try {
                                const parsed = JSON.parse(data);
                                const content = parsed.choices?.[0]?.delta?.content;

                                if (content) {
                                    assistantMessage += content;

                                    // Create or update message element
                                    if (!messageElement) {
                                        typingIndicator.classList.remove('active');
                                        messageElement = addMessage('assistant', assistantMessage);
                                    } else {
                                        // Update with markdown rendering during streaming
                                        try {
                                            messageElement.innerHTML = marked.parse(assistantMessage);
                                        } catch (err) {
                                            messageElement.textContent = assistantMessage;
                                        }
                                    }

                                    scrollToBottom();
                                }
                            } catch (e) {
                                // Ignore parsing errors for incomplete chunks
                            }
                        }
                    }
                }

                // Add assistant response to history
                if (assistantMessage) {
                    conversationHistory.push({
                        role: 'assistant',
                        content: assistantMessage
                    });
                }

            } catch (error) {
                console.error('Error:', error);
                typingIndicator.classList.remove('active');

                if (error.message.includes('Invalid API key')) {
                    addMessage('error', 'âŒ Invalid API key. Get a new one from Telegram: /getapikey');
                } else if (error.message.includes('Insufficient credits')) {
                    addMessage('error', 'âŒ ' + error.message);
                } else {
                    addMessage('error', 'âŒ Error: ' + error.message);
                }
            } finally {
                // Re-enable input
                messageInput.disabled = false;
                sendButton.disabled = false;
                sendButton.classList.remove('loading');
                messageInput.focus();
                typingIndicator.classList.remove('active');

                // Update credit balance
                updateCreditBalance();

                // Reload conversations to get updated titles
                await loadConversations();
            }
        }

        function scrollToBottom() {
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // Focus input on load
        if (apiKey) {
            messageInput.focus();
        }
    </script>
    </div> <!-- end main-wrapper -->

    <!-- Command Palette FAB Button -->
    <button class="command-palette-fab" id="command-palette-fab" title="Open Command Palette (Ctrl+K)">
        âŒ˜
    </button>
</body>
</html>
